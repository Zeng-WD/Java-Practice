代理类在程序运行时创建的代理方式被成为 动态代理。
JVM 的类加载机制中的加载阶段要做的三件事情
    通过一个类的全名或其它途径来获取这个类的二进制字节流
    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口

动态代理，主要发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。
其中运行时计算生成就是动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。
所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进 JVM 中。实际计算的情况会很复杂，会借助一些诸如 JDK 动态代理实现、CGLIB 第三方库来完成的

另一方面为了让生成的代理类与目标对象 (就是委托类) 保持一致, 有 2 种做法：通过接口的 JDK 动态代理 和通过继承类的 CGLIB 动态代理。

java 动态代理最大的特点就是动态生成的代理类和委托类实现同一个接口。
java 动态代理其实内部是通过反射机制实现的，也就是已知的一个对象，在运行的时候动态调用它的方法，并且调用的时候还可以加一些自己的逻辑在里面。

